plugins {
  // Apply the java plugin to add support for Java
  id 'java'
  id 'idea'
  id 'pmd'
  id 'checkstyle'
  id 'jacoco'
  id 'war'
}

war {
  archiveName = 'radar.war'
}

targetCompatibility = '1.8'
sourceCompatibility = '1.8'

ext.codacyVersion = '1.0.10'
ext.dataformat = '2.8.5'
ext.jackson='2.8.4'
ext.jersey = '2.22.1'
ext.jerseymedia = '2.24'
ext.json='20160810'
ext.junitVersion = '4.12'
ext.logback = '1.1.7'
ext.mathVersion = '3.0'
ext.mokitoVersion ='1.10.19'
ext.mongodb='3.3.0'
ext.okhttpVersion = '3.5.0'
ext.okioVersion = '1.11.0'
ext.openCsvVersion = '3.9'
ext.radarCommon = '0.3.1-SNAPSHOT'
ext.radarCommonTesting = '0.3.1-SNAPSHOT'
ext.radarSchemasCommon = '0.1'
ext.snakeyaml='1.17'
ext.swagger='1.5.0'
ext.swaggerParser='1.0.24'
ext.tomcat = '8.0.43'
ext.schemaRestApi = '0.1.1-alpha.1'

configurations {
  codacy
  //Integration test for REST API only
  integrationTestCompile.extendsFrom testCompile
  integrationTestRuntime.extendsFrom testRuntime
  //End to end tests
  endToEndTestCompile.extendsFrom integrationTestCompile
  endToEndTestCompile.extendsFrom integrationTestRuntime
  provided
  compile.extendsFrom provided
}

// In this section you declare where to find the dependencies of your project
repositories {
  // Use 'jcenter' for resolving your dependencies.
  // You can declare any Maven/Ivy/file repository here.
  // For working with dev-branchs
  maven { url "${rootProject.projectDir}/libs" }
  jcenter()
  maven { url 'http://packages.confluent.io/maven/' }
  maven { url 'https://jitpack.io' }
  maven { url 'http://dl.bintray.com/typesafe/maven-releases' }
  maven { url 'https://dl.bintray.com/radar-cns/org.radarcns' }
}

// In this section you declare the dependencies for your production and test code
dependencies {
  providedCompile group: 'org.apache.tomcat', name: 'tomcat-catalina', version: tomcat
  compile group: 'org.radarcns' , name: 'radar-schemas-restapi' , version: schemaRestApi

  compile group: 'ch.qos.logback', name:'logback-classic', version: logback

  compile group: 'org.glassfish.jersey.containers', name: 'jersey-container-servlet', version: jersey
  compile group: 'org.json', name: 'json', version: json
  compile group: 'io.swagger', name: 'swagger-jersey2-jaxrs', version: swagger
  compile group: 'org.mongodb', name: 'mongo-java-driver', version: mongodb
  compile group: 'com.fasterxml.jackson.datatype', name: 'jackson-datatype-joda', version: jackson
  compile group: 'org.yaml', name: 'snakeyaml', version: snakeyaml
  compile group: 'org.glassfish.jersey.media', name: 'jersey-media-json-jackson', version: jerseymedia
  compile group: 'com.fasterxml.jackson.dataformat', name: 'jackson-dataformat-avro', version: dataformat
  compile group: 'org.radarcns', name: 'radar-commons', version: radarCommon

  testCompile group: 'junit', name: 'junit', version: junitVersion
  testCompile group: 'org.radarcns' , name: 'radar-commons-testing' , version: radarCommonTesting
  testCompile group: 'org.radarcns', name: 'radar-schemas-commons', version: radarSchemasCommon
  testCompile group: 'org.apache.commons', name: 'commons-math3', version: mathVersion
  testCompile group: 'com.squareup.okhttp3', name: 'okhttp', version: okhttpVersion
  testCompile group: 'com.squareup.okio', name: 'okio', version: okioVersion
  testCompile group: 'io.swagger', name: 'swagger-parser', version: swaggerParser

  codacy group: 'com.github.codacy', name: 'codacy-coverage-reporter', version: codacyVersion
}

//---------------------------------------------------------------------------//
// Source Set                                                                //
//---------------------------------------------------------------------------//

sourceSets {
  integrationTest {
    java {
      compileClasspath += main.output + test.output
      runtimeClasspath += main.output + test.output
      srcDir file('src/integrationTest/java')
    }
    resources {
      srcDir 'src/integrationTest/resources'
    }
  }
  endToEndTest {
    java {
      compileClasspath += main.output + test.output + integrationTest.output
      runtimeClasspath += main.output + test.output + integrationTest.output
      srcDir file('src/endToEndTest/java')
    }
    resources {
      srcDir 'src/endToEndTest/resources'
    }
  }
}

//---------------------------------------------------------------------------//
// Style checking                                                            //
//---------------------------------------------------------------------------//

checkstyle {
  // codacy version
  toolVersion '6.16'
  ignoreFailures false

  // ignore tests
  sourceSets = [sourceSets.main, sourceSets.test, sourceSets.integrationTest, sourceSets.endToEndTest]
}

pmd {
  // pmd version
  toolVersion = '5.5.2'
  ignoreFailures = false

  sourceSets = [sourceSets.main, sourceSets.test, sourceSets.integrationTest, sourceSets.endToEndTest]

  consoleOutput = true

  ruleSets = []
  ruleSetFiles = files("config/pmd/ruleset.xml")
}


pmdTest {
  ruleSetFiles = files("config/pmd/test_ruleset.xml")
}

//---------------------------------------------------------------------------//
// Testing                                                                   //
//---------------------------------------------------------------------------//

tasks.matching {it instanceof Test}.all {
  def stdout = new LinkedList<String>()
  beforeTest { TestDescriptor td ->
    stdout.clear()
  }

  onOutput { TestDescriptor td, TestOutputEvent toe ->
    stdout.addAll(toe.getMessage().split('(?m)$'))
    while (stdout.size() > 100) {
      stdout.remove()
    }
  }

  afterTest { TestDescriptor td, TestResult tr ->
    if (tr.resultType == TestResult.ResultType.FAILURE) {
      println()
      print("${td.className}.${td.name} FAILED")
      if (stdout.empty) {
        println(" without any output")
      } else {
        println(" with last 100 lines of output:")
        println('=' * 100)
        stdout.each { print(it) }
        println('=' * 100)
      }
    }
  }

  testLogging {
    showExceptions = true
    showCauses = true
    showStackTraces = true
    exceptionFormat "full"
  }
}

test {
  testLogging {
    // Show that tests are run in the command-line output
    events "skipped", "failed"
  }
}

task integrationTest(type: Test) {
  description = "Run integration tests (located in src/integrationTest/...)."

  testClassesDir = sourceSets.integrationTest.output.classesDir
  classpath = sourceSets.integrationTest.runtimeClasspath

  // This is not needed, but I like to see which tests have run
  testLogging {
    events "skipped", "failed"
  }
}

//---------------------------------------------------------------------------//
// Docker Utility                                                            //
//---------------------------------------------------------------------------//
ext.dockerCompose = hasProperty('dockerComposePath') ? property('dockerComposePath') : 'docker-compose'
ext.sudoLinux = System.properties['os.name'].toLowerCase().contains('linux') ? ['sudo'] : []

//---------------------------------------------------------------------------//
// Integration Test                                                          //
//---------------------------------------------------------------------------//
ext.simpleStackPath = 'src/integrationTest'
ext.simpleStackLock = "${simpleStackPath}/.RUNNING_INSTANCE_LOCK"

task buildDocker(type: Exec, dependsOn: 'copyWarForIntegration') {
  workingDir 'src/integrationTest/image'
  commandLine sudoLinux + ['docker', 'image', 'build', '.']
}

task installSimpleStack(type: Exec, dependsOn: ['buildDocker']) {
  doFirst{
    def lockFile = new File(simpleStackLock)
    if (lockFile.exists()) {
      throw new GradleException("A previous instance of the simple stack is still running. Please stop it first and then try again.")
    } else {
      lockFile.createNewFile()
    }

    def radarVolumePath = "${simpleStackPath}/volumes/radar"
    file(radarVolumePath).mkdirs()

    def configJson = file("${simpleStackPath}/resources/config.json")
    file("${radarVolumePath}/config.json") << configJson.text

    def catalogYml = file("${simpleStackPath}/resources/device-catalog.yml")
    file("${radarVolumePath}/device-catalog.yml") << catalogYml.text

    def radarYml = file("${simpleStackPath}/resources/radar.yml")
    file("${radarVolumePath}/radar.yml") << radarYml.text.replace("localhost: 27017", "hotstorage: 27017")
  }

  workingDir simpleStackPath
  standardInput = System.in
  commandLine sudoLinux + [dockerCompose, 'up', '-d']

  doLast {
    // wait until the hotstorage is ready
    sleep(10_000)
  }
}
integrationTest.dependsOn 'installSimpleStack'

task stopSimpleStack(type: Exec) {
  onlyIf{
    new File(simpleStackLock).exists()
  }
  standardInput = System.in
  workingDir simpleStackPath
  commandLine sudoLinux + [dockerCompose, 'down', '-v']
  doLast{
    new File(simpleStackLock).delete()
  }
}

integrationTest.finalizedBy 'stopSimpleStack'

task cleanSimpleStack(type: Delete, dependsOn: stopSimpleStack) {
  delete "${simpleStackPath}/volumes"
  delete simpleStackLock
}

stopSimpleStack.finalizedBy cleanSimpleStack
clean.dependsOn cleanSimpleStack


//---------------------------------------------------------------------------//
// End to End Test                                                           //
//---------------------------------------------------------------------------//
ext.radarStackPath = 'src/endToEndTest/dockerRadar/dcompose-stack/radar-cp-hadoop-stack'
ext.radarStackLock = "${radarStackPath}/.RUNNING_INSTANCE_LOCK"

task endToEndTest(type: Test, dependsOn: ['installRadarStack', 'listDockerProcesses']) {
  description = "Run end to end tests (located in src/endToEndTest/...)."

  testClassesDir = sourceSets.endToEndTest.output.classesDir
  classpath = sourceSets.endToEndTest.runtimeClasspath

  testLogging {
    events "failed"

    debug {
      events "started", "skipped", "failed"
      exceptionFormat "full"
    }
  }

  testLogging.showStandardStreams = true
}
endToEndTest.finalizedBy 'stopRadarStack'

task installRadarStack(type: Exec, dependsOn: ['setRadarEnvironmentForDocker', 'buildDocker']) {
  doFirst{
    def lockFile = new File(radarStackLock)
    if (lockFile.exists()) {
      throw new GradleException("A previous instance of RADAR Platform is still running. Please stop it first and then try again.")
    } else {
      lockFile.createNewFile()
    }
  }

  workingDir radarStackPath
  standardInput = System.in
  commandLine sudoLinux + ['./install-radar-stack.sh']
}

task listDockerProcesses(type: Exec) {
  workingDir radarStackPath
  standardInput = System.in
  commandLine sudoLinux + [dockerCompose, 'ps']
}
listDockerProcesses.mustRunAfter 'installRadarStack'

ext.stoppingStack = false
task stopRadarStack(type: Exec) {
  onlyIf{
    new File(radarStackLock).exists() && !stoppingStack
  }
  doFirst{
    stoppingStack = true
  }

  standardInput = System.in
  workingDir radarStackPath
  commandLine sudoLinux + [dockerCompose, 'down', '-v']

  doLast{
    stoppingStack = false
  }
}

task cleanRadarStack(type: Delete, dependsOn: stopRadarStack) {
  onlyIf{
    !stoppingStack
  }

  delete "${radarStackPath}/volumes"
  delete radarStackLock
}
stopRadarStack.finalizedBy cleanRadarStack
clean.dependsOn cleanRadarStack

// Sets configuration files for running the entire platform
task setRadarEnvironmentForDocker {
  doLast {
    def envTemplatePath = "${radarStackPath}/etc/env.template"
    def smtpTemplatePath = "${radarStackPath}/etc/smtp.env.template"
    def streamTemplatePath = "${radarStackPath}/etc/radar.yml.template"

    def volumes = file("${radarStackPath}/volumes")
    volumes.mkdir()

    def fileEnv = file(envTemplatePath + 'tmp')
    fileEnv << file(envTemplatePath).text
    fileEnv.text = fileEnv.text.replace('/usr/local/var/lib/docker', volumes.getAbsolutePath())
    fileEnv.text = fileEnv.text.replace('HOTSTORAGE_USERNAME=<mongodb-user>', 'HOTSTORAGE_USERNAME=restapi')
    fileEnv.text = fileEnv.text.replace('HOTSTORAGE_PASSWORD=XXXXXXXX', 'HOTSTORAGE_PASSWORD=radarcns')
    fileEnv.text = fileEnv.text.replace('HOTSTORAGE_NAME=<mongodb-database>', 'HOTSTORAGE_NAME=hotstorage')
    fileEnv.renameTo("${radarStackPath}/.env")

    def fileSmtp = file(smtpTemplatePath + 'tmp')
    fileSmtp << file(smtpTemplatePath).text
    fileSmtp.renameTo("${radarStackPath}/etc/smtp.env")

    def fileStream = file(streamTemplatePath + 'tmp')
    fileStream << file(streamTemplatePath).text
    fileStream.renameTo("${radarStackPath}/etc/radar.yml")

    def installScript = file("${radarStackPath}/install-radar-stack.sh")
    installScript.text = installScript.text.replace(' docker-compose ', " ${dockerCompose} ")
  }
}

//---------------------------------------------------------------------------//
// Code coverage and codacy                                                  //
//---------------------------------------------------------------------------//

jacocoTestReport {
  executionData test, integrationTest
  reports {
    xml.enabled true
    csv.enabled false
    html.enabled true
  }
}

task downloadDependencies(type: Exec) {
  configurations.testRuntime.files
  configurations.codacy.files
  configurations.jacocoAnt.files
  commandLine 'echo', 'Downloaded all dependencies'
}

task sendCoverageToCodacy(type: JavaExec, dependsOn: jacocoTestReport) {
  main = 'com.codacy.CodacyCoverageReporter'
  classpath = configurations.codacy
  args = ['-l', 'Java', '-r', "${buildDir}/reports/jacoco/test/jacocoTestReport.xml"]
}

//---------------------------------------------------------------------------//
// Prepare FRONT-END config file                                             //
//---------------------------------------------------------------------------//
task copyFrontendConfig(type: Copy) {
  from "${projectDir}/schemas/restapi/config/config.json"
  into "${projectDir}/src/main/webapp/frontend/"
}
war.dependsOn(copyFrontendConfig)

task copyFrontendConfigIntegrationTest(type: Copy) {
  from "${projectDir}/schemas/restapi/config/config.json"
  into "${projectDir}/src/integrationTest/resources"
}
integrationTest.dependsOn(copyFrontendConfigIntegrationTest)

task copyFrontendConfigEndToEndTest(type: Copy) {
  from "${projectDir}/schemas/restapi/config/config.json"
  into "${projectDir}/src/endToEndTest/resources"
}
endToEndTest.dependsOn(copyFrontendConfigEndToEndTest)

task removeFrontendConfig(type: Delete) {
  delete "${projectDir}/src/main/webapp/frontend/"
  delete "${projectDir}/src/integrationTest/resources/config.json"
  delete "${projectDir}/src/endToEndTest/resources/config.json"
}
clean.dependsOn(removeFrontendConfig)

//---------------------------------------------------------------------------//
// Prepare WAR                                                               //
//---------------------------------------------------------------------------//
task copyWarForIntegration(type: Copy, dependsOn: war) {
  from war.archivePath
  into "${projectDir}/src/integrationTest/image"
}

task removeWar(type: Delete) {
  delete "${projectDir}/src/integrationTest/image/${war.getArchiveName()}"
}

war.finalizedBy copyWarForIntegration
clean.dependsOn(removeWar)

//---------------------------------------------------------------------------//
// Build system metadata                                                     //
//---------------------------------------------------------------------------//

idea {
  module {
    sourceDirs += file("build/avro")
  }
}

task wrapper(type: Wrapper) {
  gradleVersion = '3.4.1'
}
