plugins {
  // Apply the java plugin to add support for Java
  id 'java'
  id 'idea'
  id 'pmd'
  id 'checkstyle'
  id 'jacoco'
  id 'war'
}

war {
  archiveName = 'radar.war'
}

targetCompatibility = '1.7'
sourceCompatibility = '1.7'

ext.avro='1.7.7'
ext.codacyVersion = '1.0.10'
ext.dataformat = '2.8.5'
ext.jackson='2.8.4'
ext.jersey = '2.22.1'
ext.jerseymedia = '2.24'
ext.json='20160810'
ext.junitVersion = '4.12'
ext.logback = '1.1.7'
ext.mathVersion = '3.0'
ext.mokitoVersion ='1.10.19'
ext.mongodb='3.3.0'
ext.okhttpVersion = '3.5.0'
ext.okioVersion = '1.11.0'
ext.openCsvVersion = '3.9'
ext.radarCommon = '0.3-SNAPSHOT'
ext.snakeyaml='1.17'
ext.swagger='1.5.0'
ext.tomcat = '8.0.37'
ext.schemaRestApiVersion = '0.1.1-SNAPSHOT'

configurations {
  codacy
  //Integration test for REST API only
  integrationTestCompile.extendsFrom testCompile
  integrationTestRuntime.extendsFrom testRuntime
  //End to end tests
  endToEndTestCompile.extendsFrom integrationTestCompile
  endToEndTestCompile.extendsFrom integrationTestRuntime
  provided
  compile.extendsFrom provided
}

// In this section you declare where to find the dependencies of your project
repositories {
  // Use 'jcenter' for resolving your dependencies.
  // You can declare any Maven/Ivy/file repository here.
  // For working with dev-branchs
  maven { url "${rootProject.projectDir}/libs" }
  jcenter()
  maven { url 'http://packages.confluent.io/maven/' }
  maven { url 'https://jitpack.io' }
  maven { url 'http://dl.bintray.com/typesafe/maven-releases' }
  maven { url 'https://dl.bintray.com/radar-cns/org.radarcns' }
}

// In this section you declare the dependencies for your production and test code
dependencies {
  // The production code runs on tomcat 8.0.37
  providedCompile group: 'org.apache.tomcat', name: 'tomcat-catalina', version: tomcat
  compile group: 'org.radarcns' , name: 'radar-schemas-restapi' , version: schemaRestApiVersion

  // The production code uses the SLF4J logging API at compile time
  compile group: 'ch.qos.logback', name:'logback-classic', version: logback

  compile group: 'org.glassfish.jersey.containers', name: 'jersey-container-servlet', version: jersey
  compile group: 'org.json', name: 'json', version: json
  compile group: 'io.swagger', name: 'swagger-jersey2-jaxrs', version: swagger
  compile group: 'org.mongodb', name: 'mongo-java-driver', version: mongodb
//  compile group: 'ch.qos.logback', name: 'logback-classic', version: logback
  compile group: 'org.apache.avro', name: 'avro', version: avro
  compile group: 'com.fasterxml.jackson.datatype', name: 'jackson-datatype-joda', version: jackson
  compile group: 'org.yaml', name: 'snakeyaml', version: snakeyaml
  compile group: 'org.glassfish.jersey.media', name: 'jersey-media-json-jackson', version: jerseymedia
  compile group: 'com.fasterxml.jackson.dataformat', name: 'jackson-dataformat-avro', version: dataformat
  compile group: 'org.radarcns', name: 'radar-commons', version: radarCommon

  testCompile group: 'junit', name: 'junit', version: junitVersion
  integrationTestCompile group: 'org.radarcns' , name: 'radar-commons-testing' , version: radarCommon

//  testCompile group: 'com.opencsv', name: 'opencsv', version: openCsvVersion
  testCompile group: 'org.apache.commons', name: 'commons-math3', version: mathVersion
  testCompile group: 'com.squareup.okhttp3', name: 'okhttp', version: okhttpVersion
  testCompile group: 'com.squareup.okio', name: 'okio', version: okioVersion
  testCompile group: 'org.mockito', name: 'mockito-all', version: mokitoVersion

  codacy group: 'com.github.codacy', name: 'codacy-coverage-reporter', version: codacyVersion
}

//---------------------------------------------------------------------------//
// AVRO file manipulation                                                    //
//---------------------------------------------------------------------------//

//task generateAvro(type: com.commercehub.gradle.plugin.avro.GenerateAvroJavaTask) {
//  source("schemas/restapi")
//  outputDir = file("build/avro")
//}
//
//compileJava.source(generateAvro.outputs)

//---------------------------------------------------------------------------//
// Source Set                                                                //
//---------------------------------------------------------------------------//

sourceSets {
  integrationTest {
    java {
      compileClasspath += main.output + test.output
      runtimeClasspath += main.output + test.output
      srcDir file('src/integrationTest/java')
    }
    resources {
      srcDir 'src/integrationTest/resources'
    }
  }
  endToEndTest {
    java {
      compileClasspath += main.output + test.output + integrationTest.output
      runtimeClasspath += main.output + test.output + integrationTest.output
      srcDir file('src/endToEndTest/java')
    }
    resources {
      srcDir 'src/endToEndTest/resources'
    }
  }
}

//---------------------------------------------------------------------------//
// Style checking                                                            //
//---------------------------------------------------------------------------//

checkstyle {
  // codacy version
  toolVersion '6.16'
  ignoreFailures true

  // ignore tests
  sourceSets = [sourceSets.main]
}

pmd {
  // pmd version
  toolVersion = '5.5.2'
  ignoreFailures = true

  // ignore tests
  sourceSets = [sourceSets.main]

  consoleOutput = true

  ruleSets = []
  ruleSetFiles = files("config/pmd/ruleset.xml")
}


pmdTest {
  ruleSetFiles = files("config/pmd/test_ruleset.xml")
}

//---------------------------------------------------------------------------//
// Testing                                                                   //
//---------------------------------------------------------------------------//

tasks.matching {it instanceof Test}.all {
  def stdout = new LinkedList<String>()
  beforeTest { TestDescriptor td ->
    stdout.clear()
  }

  onOutput { TestDescriptor td, TestOutputEvent toe ->
    stdout.addAll(toe.getMessage().split('(?m)$'))
    while (stdout.size() > 100) {
      stdout.remove()
    }
  }

  afterTest { TestDescriptor td, TestResult tr ->
    if (tr.resultType == TestResult.ResultType.FAILURE) {
      println()
      print("${td.className}.${td.name} FAILED")
      if (stdout.empty) {
        println(" without any output")
      } else {
        println(" with last 100 lines of output:")
        println('=' * 100)
        stdout.each { print(it) }
        println('=' * 100)
      }
    }
  }

  testLogging {
    showExceptions = true
    showCauses = true
    showStackTraces = true
    exceptionFormat "full"
  }
}

test {
  testLogging {
    // Show that tests are run in the command-line output
    events "skipped", "failed"
  }
}

task integrationTest(type: Test) {
  description = "Run integration tests (located in src/integrationTest/...)."

  testClassesDir = sourceSets.integrationTest.output.classesDir
  classpath = sourceSets.integrationTest.runtimeClasspath

  // This is not needed, but I like to see which tests have run
  testLogging {
    events "skipped", "failed"
  }
}

//check.dependsOn integrationTest

//---------------------------------------------------------------------------//
// End to End Test                                                           //
//---------------------------------------------------------------------------//

task endToEndTest(type: Test) {
  description = "Run end to end tests (located in src/endToEndTest/...)."

  testClassesDir = sourceSets.endToEndTest.output.classesDir
  classpath = sourceSets.endToEndTest.runtimeClasspath

  testLogging {
    events "failed"
    exceptionFormat "short"

    debug {
      events "started", "skipped", "failed"
      exceptionFormat "full"
    }

    //info.events = ["failed", "skipped"]
  }

  testLogging.showStandardStreams = true
}

//Useful for E2E tests
task setRadarEnvironmentForDocker {
  doLast {
    File volumes = new File("src/endToEndTest/dockerRadar/volumes")
    volumes.mkdir()
    String volumePath = volumes.getAbsolutePath()

    def fileEnv = new File("src/endToEndTest/dockerRadar/dcompose-stack/radar-cp-hadoop-stack/etc/env.template")
    fileEnv.text = fileEnv.text.replace('/usr/local/var/lib/docker', volumePath)
    fileEnv.text = fileEnv.text.replace('HOTSTORAGE_USERNAME=<mongodb-user>', 'HOTSTORAGE_USERNAME=restapi')
    fileEnv.text = fileEnv.text.replace('HOTSTORAGE_PASSWORD=XXXXXXXX', 'HOTSTORAGE_PASSWORD=radarcns')
    fileEnv.text = fileEnv.text.replace('HOTSTORAGE_NAME=<mongodb-database>', 'HOTSTORAGE_NAME=hotstorage')
    fileEnv.renameTo("src/endToEndTest/dockerRadar/dcompose-stack/radar-cp-hadoop-stack/.env")

    def fileInstall = new File("src/endToEndTest/dockerRadar/dcompose-stack/radar-cp-hadoop-stack/install-radar-stack.sh")
    fileInstall.text = fileInstall.text.replace('/usr/local/var/lib/docker', volumePath)

    new File("src/endToEndTest/dockerRadar/dcompose-stack/radar-cp-hadoop-stack/etc/smtp.env.template").renameTo("src/endToEndTest/dockerRadar/dcompose-stack/radar-cp-hadoop-stack/etc/smtp.env")
  }
}

//---------------------------------------------------------------------------//
// Code coverage and codacy                                                  //
//---------------------------------------------------------------------------//

jacocoTestReport {
  executionData test, integrationTest
  reports {
    xml.enabled true
    csv.enabled false
    html.enabled true
  }
}

task downloadDependencies(type: Exec) {
  configurations.testRuntime.files
  configurations.codacy.files
  configurations.jacocoAnt.files
  commandLine 'echo', 'Downloaded all dependencies'
}

task sendCoverageToCodacy(type: JavaExec, dependsOn: jacocoTestReport) {
  main = 'com.codacy.CodacyCoverageReporter'
  classpath = configurations.codacy
  args = ['-l', 'Java', '-r', "${buildDir}/reports/jacoco/test/jacocoTestReport.xml"]
}

//---------------------------------------------------------------------------//
// Prepare WAR for Integration Test                                          //
//---------------------------------------------------------------------------//
task copyWarForIntegration(type: Copy) {
  from war.archivePath
  into "${projectDir}/src/integrationTest/image"
}

task removeWar(type: Delete) {
  delete "${projectDir}/src/integrationTest/image/${war.getArchiveName()}"
}

war.dependsOn(removeWar)
war.finalizedBy copyWarForIntegration

clean.dependsOn(removeWar)

//---------------------------------------------------------------------------//
// Build system metadata                                                     //
//---------------------------------------------------------------------------//

idea {
  module {
    sourceDirs += file("build/avro")
  }
}

task wrapper(type: Wrapper) {
  gradleVersion = '3.0'
}